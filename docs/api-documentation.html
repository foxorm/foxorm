<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>FoxORM - API Documention</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
	<link href="css/style.css" rel="stylesheet" type="text/css">
	<link href="img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="css/freeow.css" rel="stylesheet" type="text/css">
	<link href="css/reset-print.css" rel="stylesheet" type="text/css" media="print">
	<link href="css/animations.css" rel="stylesheet" type="text/css">
	<link href="plugins/highlightjs/styles/github-surikat.css" rel="stylesheet" type="text/css">
</head>
<body>
	<header>
		<nav class="main svelte">
			<a href="" class="logo">
				<span class="fox">Fox</span><span class="cat">ORM</span>
			</a>
			<ul>
				<li><a href="getting-started">Getting Started</a></li>
				<li><a href="documentation">Documentation</a></li>
				<li><a href="https://github.com/foxorm/foxorm" target="_blank">Github</a></li>
			</ul>
		</nav>
	</header>
	<main class="documentation">
    <div class="svelte index-me">
      <ul class="doc-menu">
        <li><a href="getting-started">Getting Started</a></li>
        <li><a href="documentation">The Paradigm</a></li>
        <li class="unfold api-documentation"><a href="api-documentation#">API Documention</a>
          <ul>
            <li><a class="page-scroll" href="api-documentation#multi-databases-registry">Multi-Databases Registry</a></li>
            <li><a class="page-scroll" href="api-documentation#database-api">Database Methods</a></li>
            <li><a class="page-scroll" href="api-documentation#relational-db-api">Relational Database Methods</a></li>
            <li><a class="page-scroll" href="api-documentation#facade">Facade API</a></li>
            <li><a class="page-scroll" href="api-documentation#table">Table</a></li>
            <li><a class="page-scroll" href="api-documentation#tablesql">Relational Table</a></li>
            <li><a class="page-scroll" href="api-documentation#tablesql-composer">Table Sql Composer API</a></li>
            <li><a class="page-scroll" href="api-documentation#entity">Entity Model</a></li>
            <li><a class="page-scroll" href="api-documentation#observer">Observer Workflow</a></li>
            <li><a class="page-scroll" href="api-documentation#relations">Relations</a></li>
            <li><a class="page-scroll" href="api-documentation#source">Data Source Plugin</a></li>
          </ul>
        </li>
      </ul>
      <article class="doc">
        <h1>FoxORM ORM - API Documentation</h1>
        <div id="documentation">
<h2 id="multi-databases-registry">Multi-Databases Registry</h2>
<h3>Bases instanciation</h3>
<p>
  The Bases class is a map registry for multiple databases.
  You can make a new one with regular "new" keyword or use the singleton defined
  in <a href="api-documentation#facade">Facade API</a> class B.
  <code class="lang-php">
use FoxORM\Bases;
$bases = new Bases();

use FoxORM\F;
$bases = F::getBases();
  </code>
</p>

<h3>Bases options</h3>
<p>
  The Bases object can be configured to set the default config of the databases.
  Each database, and even each table, can be configured independently
  and overload the default config.<br>
  If you keep the default config for primary key you can make a database which
  will be compatible with <a href="http://redbeanphp.com" target="_blank">RedBeanPHP</a> strict convention.
  <code class="lang-php">
//The followings showed parameters are the defaults
$bases->setModelClassPrefix('EntityModel\\');
$bases->setModelClassDefault('stdClass');
$bases->setPrimaryKeyDefault('id');
$bases->setUniqTextKeyDefault('uniq');

//append an other prefix for entity class lookup
$bases->appendModelClassPrefix($modelClassPrefix);

//prepend an other prefix for entity class lookup
$bases->prependModelClassPrefix($modelClassPrefix);

//enable output of queries
$bases->debug(true);
  </code>
</p>

<h3>Bases definitions</h3>
<p>
  The Bases object can be used like an array with magic acessor. The "0" index
  is the main database and default one used by <a href="api-documentation#facade">Facade API</a>.
  For relational databases,  you can define your dsn like a regular dsn or
  with assiocative keys.
  The frozen parameter tell FoxORM to not modify this database structure anymore
  to feet the request. It's to enable when you won't modify the schema and
  you want optimizations on production server.<br>
  Set databases:
  <code class="lang-php">
$bases[0] = [
'type'=>'mysql',
'host'=>'localhost',
'port'=>'3306',
'name'=>'my_db_name',

'primaryKey'=>'id',
'uniqTextKey'=>'name',
'tablePrefix'=>'mydb_',
//'frozen'=>true,
];
$bases['my_sqlite_base'] = [
'dsn'=>'sqlite:'.REDCAT_CWD.'.data/db.sqlite',
];
$bases['my_sqlite_base2'] = [
'type'=>'sqlite',
'file'=>REDCAT_CWD.'.data/db2.sqlite',
];
$bases['my_mariadb_base'] = [
'mysql:dbname=test', //dsn
'root', //user
'root', //password
];
$bases['my_postgres_base'] = [
'dsn'=>'pgsql:dbname=test;host=127.0.0.1;port=5432',
'user'=>'postgres',
'password'=>'postgres',
];

  </code>
  When you access databases offset, the Bases object return you
  the configured DataSource Object instead of config array.
  Access databases:
  <code class="lang-php">
$base = $bases[0];
$table = $base->getAll('SELECT * FROM test_table');
  </code>
</p>

<h2 id="database-api">Database Methods</h2>
<p>
  The Database is an extended class of DataSource which the name correspond
  to the type of database. The basic persistence workflow, called <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank"><strong><abbr title="Create Read Update Delete">CRUD</abbr></strong></a>,
  can be accessed from diffrent API levels:
  <a href="api-documentation#facade">Static Facade</a>,
  <a href="api-documentation#db">Database Object</a>,
  <a href="api-documentation#table">Table Object</a>.
</p>

<h3 id="db-create">create</h3>
<p>
  You can pass arguments to "create" in various way but if you pass it
  a data set which have allready a primary key defined and if that primary key
  allready exists in database table, the create will process an update instead
  an insert.
  <code class="lang-php">
$user = new stdClass; //or any other class
$user->name = 'Jo';
$base->create('user',$user);

$user = new stdClass; //or any other class
$user->_type = 'user';
$user->name = 'Jo';
$base->create($user);

$base->create('user',[
'name'=>'Jo',
]);
$base->create([
'_type'=>'user',
'name'=>'Jo',
]);

/*
if you don't pass explicitly the type and
if the "_type" meta attribute is not defined
the type will be deducted using the class name and
the "modelClassPrefix" (by default " EntityModel\ "),
if it cannot be deduct an Exception will be throwed.
*/
$user = new \EntityModel\User;
$user->name = 'Jo';
$base->create($user);
  </code>
</p>

<h3 id="db-read">read</h3>
<p>
  If you pass a string instead of an integer as second argument to "read",
  tha base will not try to lookup data by primary key but by "uniqTextKey".
  The default "uniqTextKey" is "uniq" but it can be configured on
  table like in the example.
  <code class="lang-php">
$user = $base->read('user',1);

$base['user']->setUniqTextKey('email');
$user = $base->read('user','jo@surikat.pro');
  </code>
</p>

<h3 id="db-update">update</h3>
<p>
  Like with create, you can pass arguments to "update" in various way
  but if you pass it a data set which don't have a primary key or a "uniqTextKey"
  defined the update will process an insert instead of update.
  <code class="lang-php">
$user = new stdClass; //or any other class
$user->id = 1;
$user->name = 'Jo';
$user->mtime = time();
$base->update('user',$user);

$user = new stdClass; //or any other class
$user->_type = 'user';
$user->id = 1;
$user->name = 'Jo';
$user->mtime = time();
$base->update($user);

$base->update('user',[
'id'=>1,
'name'=>'Jo',
'mtime'=>time(),
]);
$base->update([
'_type'=>'user',
'id'=>1,
'name'=>'Jo',
'mtime'=>time(),
]);

/*
if you don't pass explicitly the type and
if the "_type" meta attribute is not defined
the type will be deducted using the class name and
the "modelClassPrefix" (by default " EntityModel\ "),
if it cannot be deduct an Exception will be thrown.
*/
$user = new \EntityModel\User;
$user->name = 'Jo';
$base->update($user);
  </code>
</p>

<h3 id="db-delete">delete</h3>
<p>
  You can pass arguments to "delete" in various way.
  <code class="lang-php">
$base->delete('user',1);
$base->delete([
'_type'=>'user',
'id'=>1
]);

$base['user']->setUniqTextKey('email');
$base->delete('user','jo@surikat.pro');

/*
if you don't pass explicitly the type and
if the "_type" meta attribute is not defined
the type will be deducted using the class name and
the "modelClassPrefix" (by default " EntityModel\ "),
if it cannot be deduct an Exception will be thrown.
*/
$user = new \EntityModel\User;
$user->id = 1;
$user->name = 'Jo';
$base->delete($user);
  </code>
</p>

<h3>one2manyDelete</h3>
<p>
  Will delete all row of a table owned by another row and with a keeping
  optional parameter.
  <code class="lang-php">
$keeping = [1,2,3]; //history id
$base->one2manyDelete($user,'history',$keeping);
  </code>
</p>

<h3>many2manyDelete</h3>
<p>
  Will delete all row of a table owned by another row and with a keeping
  optional parameter.
  <code class="lang-php">
$keeping = [1,2,3]; //history id

// many to many relation table between user and history,
// by default null, according to alphabetical order
// it will implicit the join table will be history_user
$via = null;

$base->one2manyDelete($user,'history',$via,$keeping);
  </code>
</p>

<h3>entityFactory</h3>
<p>
  The entityFactory method will create an object corresponding to type name
  looking for a class corresponding to type name in "modelClassPrefix",
  and if this class is not found it will use the "entityClassDefault"
  (by default "stdClass"). The entity factory will add the "_type" meta
  property to the instancied object.
  <code class="lang-php">
$user = $base->entityFactory('user');
  </code>
</p>

<h3>setEntityFactory</h3>
<p>
  You can overload the entityFactory method using setEntityFactory.
  <code class="lang-php">
$base->setEntityFactory(function($type)use($base){
$c = $base->findModelClass($type);
$row = new $c;
$row->callSomething();
return $row;
});
  </code>
</p>


<h3>put</h3>
<p>
  The put method will determine automatically if a
  "<a href="api-documentation#db-create">create</a>"
  or an
  "<a href="api-documentation#db-update">update</a>"
  is needed,
  you can use it exactly like theses two methods.
</p>

<h3>snippet</h3>
<p>
  Some database offers a support for snippet extracting around
  searched terms from full text search, like sqlite or postgresql. But
  for those lacking this feature, here is a common snippet extractor.
  <code class="lang-php">
$base->snippet($text,$searchedTerms,$tokens=15,$start='<b>',$end='</b>',$sep=' <b>...</b> ');
  </code>
</p>


<h2 id="relational-db-api">Relational Database Methods</h2>

<h3>getAll</h3>
<p>
  The getAll method allow you to fetch all rows from a query.
  <code class="lang-php">
$rows = $base->getAll('SELECT * FROM user WHERE status = ? LIMIT 10', [ $status ]);
foreach($rows as $row){
echo $row->email."\n";
}
  </code>
</p>

<h3>getRow</h3>
<p>
  The getRow method allow you to fetch a specific row from a query.
  <code class="lang-php">
$row = $base->getRow('SELECT * FROM user WHERE id = ?', [ 1 ]);
$email = $row->email;
  </code>
</p>

<h3>getCol</h3>
<p>
  The getCol method allow you to fetch a specific column from a query.
  <code class="lang-php">
$col = $base->getCol('SELECT email FROM user WHERE status = ?', [ $status ]);
foreach($col as $email){

}
  </code>
</p>

<h3>getCell</h3>
<p>
  The getCell method allow you to fetch a specific cell from a query.
  <code class="lang-php">
$email = $base->getCell('SELECT id FROM user WHERE email = ?', [ $email ]);
  </code>
</p>

<h3>execute</h3>
<p>
  The execute method allow you execute a query.
  <code class="lang-php">
$base->execute('INSERT INTO user(name, email) VALUES( ?, ? )', [ $name, $email ] );
$affectedRows = $base->execute('UPDATE user SET email = ? WHERE id = ?', [ $email, $id ] );
  </code>
</p>

<h3>fetch</h3>
<p>
  The fetch method allow you direct access to a cursor from a query,
  so you get each row in a loop and don't overflow your php memory usage while
  traversing a whole table for example.
  <code class="lang-php">
while($row = $base->fetch('SELECT * FROM user WHERE id != 1', [ $id ])){

}
  </code>
</p>

<h3>begin</h3>
<p>
  The begin method open a transaction.
  <br>FoxORM support nested transactions, using "<a href="https://en.wikipedia.org/wiki/Savepoint" target="_blank">SAVEPOINT</a>",
  with no extra code needed.
  <br>Be carefull with transaction when the database is not "frozen",
  because the queries which altering the schema will do implicit commit
  in some databases like MySQL or Oracle. There is some workaround, with
  a secondary PDO object, that make rollback possible but not
  for the structuring queries.<br>
  <code class="lang-php">
$base->begin();
  </code>
</p>

<h3>commit</h3>
<p>
  The commit method validate and end a transaction.
  <code class="lang-php">
$base->commit();
  </code>
</p>

<h3>rollback</h3>
<p>
  The rollback method cancel and end a transaction.
  <code class="lang-php">
$base->rollback();
  </code>
</p>

<h3>getDatabaseType</h3>
<p>
  getDatabaseType return the dsn prefix:
  mysql for MySQL or MariaDB, pgsl for PostgreSQL, sqlite for SQLite
  or cubrid for CUBRID.
  <code class="lang-php">
$base->getDatabaseType();
  </code>
</p>

<h3>getDatabaseVersion</h3>
<p>
  getDatabaseVersion return the numeric decimal version of the database.
  <code class="lang-php">
$base->getDatabaseVersion();
  </code>
</p>

<h3>getPDO</h3>
<p>
  getPDO return the native PDO object used by DataSource.
  <code class="lang-php">
$pdo = $base->getPDO();
  </code>
</p>

<h3>isConnected</h3>
<p>
  isConnected return true if connected, null if not allready connected,
  and false is connection has fail.
  <code class="lang-php">
$base->isConnected();
  </code>
</p>

<h3>debug</h3>
<p>
  The debug method enable queries output, and optionaly, results and
  query explain output.
  <code class="lang-php">
$base->debug($enable=true,$loggingResult=true,$loggingExplain=true)
  </code>
</p>

<h3>nestBinding</h3>
<p>
  The nestBinding method, used automatically in internal query writer, is a helper
  allowing you to use nested array of parameters and even, contrary to native PDO,
  mix named placeholders and mark placeholders.
  <code class="lang-php">
$bindings = [
':colour'=>['red','green'],
15
];
$sql = 'SELECT name, colour, calories FROM fruit WHERE colour IN :colour AND weight < ?';
list($sql,$bindings) = FoxORM\DataSource\SQL::nestBinding($sql,$bindings);
  </code>
  And the output will be flattened like this:
  <code class="lang-php">
$sql = 'SELECT name, colour, calories FROM fruit WHERE colour IN (?,?) AND weight < ?';
$bindings = ['red','green',15];
  </code>
</p>

<h3>findOne</h3>
<p>
  The findOne method allow you to retrieve one object from database query
  using sql snippet.
  <code class="lang-php">
$base->findOne('user','name = ?',['Jo']);
  </code>
</p>
<h3>find</h3>
<p>
  The findOne method allow you to retrieve an array of objects from database query
  using sql snippet.
  <code class="lang-php">
$base->find('user','mtime < ?',[ time()-3600 ]);
  </code>
</p>
<h3>findAll</h3>
<p>
  The findAll method allow you to retrieve an array of objects from database query
  using sql snippet.
  There is no implicit WHERE, so, use it if you don't want to add any conditions
  but you want to order or limit.
  <code class="lang-php">
$base->findAll('user','ORDER BY name DESC LIMIT 10');
  </code>
</p>

<h3>findRow</h3>
<p>
  The findRow method allow you to retrieve one result as an associative array
  from database query using sql snippet. There is no implicit WHERE.
  <code class="lang-php">
$base->findRow('user','WHERE name = ?',['Jo']);
  </code>
</p>
<h3>findRows</h3>
<p>
  The findRow method allow you to retrieve an array of results, as associatives arrays,
  from database query using sql snippet. There is no implicit WHERE.
  <code class="lang-php">
$base->findRows('user','WHERE mtime < ? ORDER BY name DESC LIMIT 10',[ time()-3600 ]);
  </code>
</p>

<h3>bindRead</h3>
<p>
  The bindRead method allow you to wrap <i>SELECT</i> columns in functions.
  <code class="lang-php">
$base->bindRead('location','point','asText');
$location = $base->read('location',1);
  </code>
  You can also add nested function using mark <i>?</i>
  in substitution of column name.
  <code class="lang-php">
$base->bindRead('location','point','SUBSTR(asText(?),5)');
$location = $base->read('location',1);
  </code>
  And even alias them.
  <code class="lang-php">
$base->bindRead('location','point','asText(?) as point_text');
$location = $base->read('location',1);
  </code>
</p>

<h3>bindWrite</h3>
<p>
  The bindRead method allow you to wrap <i>INSERT</i> and <i>UPDATE</i>
  columns in functions.
  <code class="lang-php">
$location->point = 'POINT(14 6)';
$base->bindWrite('location','point','GeomFromText');
$base->create('location',$location);
  </code>
  You can also add nested function using mark <i>?</i>
  in substitution of column name.
  <code class="lang-php">
$location->point = '(14 6)';
$base->bindWrite('location','point',"GeomFromText(CONCAT('POINT',?))");
$base->create('location',$location);
  </code>
</p>

<h3>unbindRead</h3>
<p>
  The unbindRead method unset bindRead functions from stack.<br>
  If you pass it one argument it will unset all bindRead functions
  for the specified type.<br>
  If you pass it two argument it will unset all bindRead functions
  for the specified type and column.<br>
  If you pass it three argument it will unset all bindRead functions
  for the specified type and column and which is the same function as passed
  in third argument.<br>
  <code class="lang-php">
$base->unbindRead('location');
$base->unbindRead('location','point');
$base->unbindRead('location','point','asText');
  </code>
</p>
<h3>unbindWrite</h3>
<p>
  The unbindWrite method unset bindWrite functions from stack.<br>
  If you pass it one argument it will unset all bindWrite functions
  for the specified type.<br>
  If you pass it two argument it will unset all bindWrite functions
  for the specified type and column.<br>
  If you pass it three argument it will unset all bindWrite functions
  for the specified type and column and which is the same function as passed
  in third argument.<br>
  <code class="lang-php">
$base->unbindWrite('location');
$base->unbindWrite('location','point');
$base->unbindWrite('location','point','GeomFromText');
  </code>
</p>


<h3>setSQLFiltersRead</h3>
<p>
  Reset all bindRead functions and define a map manually.
  <code class="lang-php">
$base->setSQLFiltersRead([
'location'=>[
'point'=>'asText',
]
]);
  </code>
</p>
<h3>setSQLFiltersWrite</h3>
<p>
  Reset all bindWrite functions and define a map manually.
  <code class="lang-php">
$base->setSQLFiltersWrite([
'location'=>[
'point'=>'GeomFromText',
]
]);
  </code>
</p>

<h3>getSQLFiltersRead</h3>
<p>
  Return the bindRead functions map.
  <code class="lang-php">
$bindReadMap = $base->getSQLFiltersRead();
  </code>
</p>
<h3>getSQLFiltersWrite</h3>
<p>
  Return the bindWrite functions map.
  <code class="lang-php">
$bindWriteMap = $base->getSQLFiltersWrite();
  </code>
</p>

<h3>getReadSnippetCol</h3>
<p>
  Return sql snippet related to column select from bindRead map.
  Sql snippet is for use query.
  <code class="lang-php">
$columnSqlSnippet = $base->getReadSnippetCol('location','point');
$base->getAll("SELECT $type.*, $columnSqlSnippet FROM $type");
  </code>
</p>

<h3>check</h3>
<p>
  Will throw an InvalidArgumentException Exception if you pass to it an invalid
  table or column name (alphanumeric, hyphen -, underscore _). To protect
  dynamic table or column name in manual query building from SQL injection.
  <code class="lang-php">
$base->check($struct);
  </code>
</p>

<h3>esc</h3>
<p>
  Check table or column name is valid and
  add quote specific to current database type.
  <code class="lang-php">
$columnOrTableWithQuotes = $base->esc($esc);
  </code>
</p>

<h3>escTable</h3>
<p>
  Check table name is valid,
  add prefix if there is a prefix table associated to the current database,
  and then add quote specific to current database type.
  <code class="lang-php">
$tableWithPrefixAndQuotes = $base->escTable($type);
  </code>
</p>

<h3>prefixTable</h3>
<p>
  Check table name is valid and
  add prefix if there is a prefix table associated to the current database.
  <code class="lang-php">
$tableWithPrefix = $base->prefixTable($type);
  </code>
</p>

<h3>unprefixTable</h3>
<p>
  Remove the prefix if there is a prefix table associated to the current database
  and if it's present in parameter.
  <code class="lang-php">
$tableWithoutPrefix = $base->unprefixTable($tableWithPrefix);
  </code>
</p>

<h3>unEsc</h3>
<p>
  Trim quote specific to current database type from parameter.
  <code class="lang-php">
$tableOrColumnWithoutQuotes = $base->unEsc($esc);
  </code>
</p>

<h3>getQuoteCharacter</h3>
<p>
  Return quote specific to current database type.
  <code class="lang-php">
$quoteCharacter = $base->getQuoteCharacter();
  </code>
</p>

<h3>getTablePrefix</h3>
<p>
  Return prefix table associated to the current database.
  <code class="lang-php">
$tablePrefix = $base->getTablePrefix();
  </code>
</p>

<h3>tableExists</h3>
<p>
  Check if a table exists. Second parameter, set to true by default,
  is for automatically add prefix to table.
  <code class="lang-php">
if($base->tableExists($type)){

}
if($base->tableExists($tableWithPrefix,false)){

}
  </code>
</p>

<h3>getTables</h3>
<p>
  Get the table names list.
  <code class="lang-php">
$tables = $base->getTables();
  </code>
</p>

<h3>columnExists</h3>
<p>
  Check if a column exists in a table. Table name is automatically prefixed.
  <code class="lang-php">
if($base->columnExists($type,$column)){

}
  </code>
</p>

<h3>getColumns</h3>
<p>
  Get the columns names list for a table. Table name is automatically prefixed.
  <code class="lang-php">
$columns = $base->getColumns($type);
  </code>
</p>

<h3>addColumn</h3>
<p>
  Add a colum to table manually. Table name is automatically prefixed.
  <code class="lang-php">
$base->addColumn($type,$column,$field);
  </code>
</p>

<h3>changeColumn</h3>
<p>
  Change a table's colum manually. Table name is automatically prefixed.
  <code class="lang-php">
$base->changeColumn($type,$column,$field);
  </code>
</p>

<h3>createTable</h3>
<p>
  Create a table manually. Table name is automatically prefixed.
  <code class="lang-php">
$base->createTable($type,$pk='id');
  </code>
</p>

<h3>drops</h3>
<p>
  Drop a list of table of the database. Table names are automatically prefixed.
  You can pass it a list of scalar names or arrays.
  <code class="lang-php">
$base->drops('table1','table2');
$base->drops(['table1','table2']);
  </code>
</p>

<h3>drop</h3>
<p>
  Drop a specific table of the database. Table name is automatically prefixed.
  <code class="lang-php">
$base->drop('mytable');
  </code>
</p>

<h3>dropAll</h3>
<p>
  Drop all table of the database.
  <code class="lang-php">
$base->dropAll();
  </code>
</p>

<h3>many2one</h3>
<p>
  Getting the one (parent).
  Get a type of related by column object from another object. For instance, retrieve
  the row from user table corresponding to <i>user_id</i> (if primaryKey of user is id)
  from table project where project <i>id</i> = 1.
  <code class="lang-php">
$project = $base->read('project',1);
$user = $base->many2one($project,'user');
  </code>
</p>

<h3>one2many</h3>
<p>
  Getting the many (owns).
  Get a type of related by column objects from an object. For instance, retrieve
  the rows from project table where <i>user_id</i> (if primaryKey of user is id) = 1.
  <code class="lang-php">
$user = $base->read('user',1);
$projectList = $base->one2many($user,'project');
  </code>
</p>

<h3>many2many</h3>
<p>
  Getting the many (shared).
  Get a type of related objects from an object via a junction table.
  If you don't specify a junction table, the convention is to order names
  of tables alphabetically and join them with an underscore "_". For instance
  with user and project, the implicit junction table will be "project_user".
  <code class="lang-php">
$user = $base->read('user',1);
$projectList = $base->many2many($user,'project');

$project = $base->read('project',1);
$userList = $base->many2many($project,'user');

$project = $base->read('project',1);
$authorList = $base->many2many($project,'user','author');
  </code>
</p>

<h3>many2manyLink</h3>
<p>
  Getting the many (shared).
  Get a type of related objects from an object via a junction table.
  Difference with many2many is that you can specify the foreign key target.
  <code class="lang-php">
$project = $base->read('project',1);
$authorList = $base->many2manyLink($project,'user','author','creator_id');
  </code>
</p>

<h3>addFK</h3>
<p>
  Manually add foreign key to a table.
  <code class="lang-php">
$base->addFK($type,$targetType,$column,$targetColumn,$cascade);
$base->addFK('project','user','user_id','id',true);
  </code>
</p>

<h3>getKeyMapForType</h3>
<p>
  Get the foreign key map of a table.
  <code class="lang-php">
$fkMap = $base->getKeyMapForType('project');
  </code>
  $fkMap will contain an associative array like this one
  <code class="lang-php">
[
'from_user_id_to_table_user_col_id'=>[ //conventional label
'name'      => 'project_user_id_fkey', //index name
'table'     => 'user',
'from'      => 'user_id',
'to'        => 'id',
'on_update' => 'CASCADE',
'on_delete' => 'CASCADE'
],
]
  </code>
</p>

<h3>addUniqueConstraint</h3>
<p>
  Manually add unique constraint to one or multiple column of a table.
  If you use multiple columns it's not the same as using multiple time
  a single column, multiple column on a unique constraint mean that it's
  the combination of these columns which should be unique.
  <code class="lang-php">
$base->addUniqueConstraint('user','email');
$base->addUniqueConstraint('user',['name','lastname']);
  </code>
</p>

<h3>addIndex</h3>
<p>
  Manually add a named index to a column of a table.
  <code class="lang-php">
$base->addIndex($type,$name,$column);
$base->addIndex('user','email_index','email');
  </code>
</p>

<h3>clear</h3>
<p>
  Remove all entries from a table without altering it's structure.
  <code class="lang-php">
$base->clear('user');
  </code>
</p>

<h3>drop</h3>
<p>
  Remove a whole table from the database and, of course, all it's entries.
  <code class="lang-php">
$base->drop('user');
  </code>
</p>

<h3>dropAll</h3>
<p>
  Remove all tables from the database.
  <code class="lang-php">
$base->dropAll();
  </code>
</p>

<h2 id="facade">F Static Facade API</h2>

<h3>getBases()</h3>
<p>
  Return the database container, the "Bases" object.
  <code class="lang-php">
$bases = F::getBases();
$base = $bases[0]; //get the default main db
  </code>
</p>

<h3>setup</h3>
<p>
  Set the default main database (key 0) dsn, user, password and config.
  <code class="lang-php">
F::setup($dsn = null, $user = null, $password = null, $config = []);
F::setup('mysql:dbname=myproject;host=localhost', 'root', 'root', [
'tablePrefix'=>'myproject_',
'frozen'=>false
]);
  </code>
</p>

<h3>addDatabase</h3>
<p>
  Add a database to the bases registry. If no database has been selected
  (or added) it will be selected automatically.
  <code class="lang-php">
F::addDatabase($key,$dsn,$user=null,$password=null,$config=[]);
F::addDatabase('myproject','mysql:dbname=myproject;host=localhost', 'root', 'root', [
'tablePrefix'=>'myproject_',
'frozen'=>false
]);
  </code>
</p>

<h3>selectDatabase</h3>
<p>
  Select (and add before if more than one argument are specified) a database
  from bases registry. For select the default main database, setted via F::setup,
  use the key "0". Return the database object.
  <code class="lang-php">
F::selectDatabase($key);
$base = F::selectDatabase(0);
$base = F::selectDatabase(0,'myproject','mysql:dbname=myproject;host=localhost', 'root', 'root', [
'tablePrefix'=>'myproject_',
'frozen'=>false
]);
  </code>
</p>

<h3>exists</h3>
<p>
  Alias of readId method. It will check if an interger id (primaryKey) or "uniqTextKey"
  exist in a table.
  <code class="lang-php">
F::exists('user',1);
F::exists('user','jo@surikat.pro');
  </code>
</p>

<h3>dispense</h3>
<p>
  Alias of entityFactory method. It will create an entity model object
  if class found or default entity class (stdClass by default).
  <code class="lang-php">
$user = F::dispense('user');
  </code>
</p>

<h3>getDatabase</h3>
<p>
  Return the current database (DataSource object) used (selected)
  by static facade api.
  <code class="lang-php">
$base = F::getDatabase();
  </code>
</p>

<h3>getTable</h3>
<p>
  Return the DataTable object corresponding to a table from the current
  selected database.
  <code class="lang-php">
$table = F::getTable($type);
$users = F::getTable('user');
  </code>
</p>

<h3>on</h3>
<p>
  Attach a callback to a table event. If callback is string, it will be interpreted
  as a method of the entity object.
  If no callback is specified it will take the event name as a method to call
  on entity object.
  You can also use a zIndex like and a prepend option.
  <code class="lang-php">
F::on($type,$event,$call);
F::on('user','afterCreate',function($entity,$db){
echo "User '{$entity->name}' created !";
});
F::on('user','afterCreate',function($entity,$db){
echo "First (prepended) callback after user '{$entity->name}' created !";
},0,true);
  </code>
</p>

<h3>off</h3>
<p>
  Detach a callback from a table event. If no callback specified it will remove all
  callbacks attached to the table event.
  You can use the zIndex like as last parameter.
  <code class="lang-php">
F::off($type,$event,$call);

$userCreated = function($entity,$db){
echo "First Callback after user '{$entity->name}' created !";
};
F::off('user','afterCreate',$userCreated,1);
F::off('user','afterCreate',$userCreated);
F::off('user','afterCreate',null,1);
F::off('user','afterCreate');
  </code>
</p>

<h3>loadMany2one</h3>
<p>
  Load the "_one_" object property from another table to an object.
  <code class="lang-php">
F::loadMany2one($obj,$type);

$project = F::read('project',1);
F::loadMany2one($project,'user');
$user = $project->_one_user;
  </code>
</p>

<h3>loadOne2many</h3>
<p>
  Load the "_many_" array of objects property from another table to an object.
  <code class="lang-php">
F::loadOne2many($obj,$type);

$user = F::read('user',1);
F::loadOne2many($user,'project');
$projects = $user->_many_project;
  </code>
</p>

<h3>loadMany2many</h3>
<p>
  Load the "_many2many_" array of objects property from another table to an object.
  A third parameter can specified for the junction table.
  If you don't specify a junction table, the convention is to order names
  of tables alphabetically and join them with an underscore "_". For instance
  with user and project, the implicit junction table will be "project_user".
  <code class="lang-php">
F::loadMany2many($obj,$type,$via=null);

$user = F::read('user',1);
F::loadMany2many($user,'project');
$projects = $user->_many2many_project;

$project = F::read('project',1);
F::loadMany2many($project,'user');
$users = $user->_many2many_user;

$user = F::read('user',1);
F::loadMany2many($user,'project','author');
$projects = $user->_many2many_project;

$project = F::read('project',1);
F::loadMany2many($project,'user','author');
$users = $user->_many2many_user;
  </code>
</p>

<h3>relayed to the Bases object</h3>
<p>
  All these followings methods are relayed to the Bases object.
  <code class="lang-php">
F::setModelClassPrefix($modelClassPrefix='EntityModel\\');
F::appendModelClassPrefix($modelClassPrefix);
F::prependModelClassPrefix($modelClassPrefix);
F::setModelClassDefault($entityClassDefault='stdClass');
F::setPrimaryKeyDefault($primaryKeyDefault='id');
F::setUniqTextKeyDefault($uniqTextKeyDefault='uniq');
  </code>
</p>

<h3>debug</h3>
<p>
  Enable debug mode for the current database.
  <code class="lang-php">
F::debug();
  </code>
</p>

<h3>magic __callStatic</h3>
<p>
  All methods that was not cited before in "<a href="api-documentation#facade">F Static Facade API</a>"
  are relayed automatically to the current database object,
  so you can use all methods explained before in
  "<a href="api-documentation#db">Database Methods</a>" and
  "<a href="api-documentation#dbsql">Relational Database Methods</a>"
  via the facade API.
  <code class="lang-php">
//eg:
F::create('user',['name'=>'Jo']);

//is equivalent to
$base->create('user',['name'=>'Jo']);
  </code>
</p>

<h2 id="table">Table</h2>

<h3>getPrimaryKey</h3>
<p>
  Get the primary key column name of the table (default "id").
  <code class="lang-php">
$primaryKey = $table->getPrimaryKey();
  </code>
</p>

<h3>getUniqTextKey</h3>
<p>
  Get the "uniqTextKey" column name of the table (default "uniq").
  "uniqTextKey" is used as a secondary main index to identify table's rows by
  a string.
  <code class="lang-php">
$uniqTextKey = $table->getUniqTextKey();
  </code>
</p>

<h3>getDataSource</h3>
<p>
  Get the database (DataSource class) parent object of the table.
  <code class="lang-php">
$base = $table->getDataSource();
  </code>
</p>

<h3>setUniqTextKey</h3>
<p>
  Set the "uniqTextKey" column name of the table (default "uniq").
  "uniqTextKey" is used as a secondary main index to identify table's rows by
  a string.
  <code class="lang-php">
$table->setUniqTextKey($uniqTextKey='uniq');
$users->setUniqTextKey('email');
  </code>
</p>

<h3>magic offset</h3>
<p>
  The greatest API feature behind FoxORM is that you can manipulate rows and
  tables like arrays. That approach was inspired by the cool,
  but not allready mature <a href="https://github.com/Level-2/Maphper" target="_blank">Maphper</a>.
  Array access interface to create, read, readId, update and delete methods.
  <code class="lang-php">
$table[] = $row;            // $table->create($id,$row);
$row = $table[1];           // $table->read($id);
$exists = isset($table[1]); // $table->readId($id);
$table[1] = $row;           // $table->update($id,$row);
unset($table[1]);           // $table->delete($id);

$user = $users[1];
$user = $users['jo@surikat.pro'];

// offset methods
$table->offsetExists($id);
$table->offsetGet($id);
$table->offsetSet($id,$obj);
$table->offsetUnset($id);
  </code>
</p>

<h3>magic iterator</h3>
<p>
  With the magic iterator you can make a loop on the table and traverse the whole
  table or a filtered table, if object was configured.<br>
  For instance with the relational database implementation,
  a cursor will be used, so, traversing a whole big table
  will not overflow your php memory usage. The key will correspond to
  primaryKey id.
  <code class="lang-php">
foreach($table as $id=>$row){

}

// iterator methods
$table->rewind(); // reset($table);
$table->current(); // current($table);
$table->key(); // key($table);
$table->valid();
$table->next(); // next($table);
  </code>
</p>

<h3>magic count</h3>
<p>
  If you call count function on a table, it will trigger the "count" method.
  For instance, in relational table it will count all rows of a table
  or the expected results if table object was configured.
  If you used the setCounter method to define a count callback it will use
  the specified callback.
  <code class="lang-php">
$count = count($table);

//count method
$count = $table->count();
  </code>
</p>

<h3>paginate</h3>
<p>
  The paginate method will create a "Pagination" helper object configured with
  parameters and count() from table, then it will resolve it to check
  the pagination is correct, adapt it's properties and finally it
  will return it to you.
  <code class="lang-php">
$pagination = $table->paginate($page,$limit=2,$href='',$prefix='?page=',$maxCols=6);

//pagination properties
$pagination->start;
$pagination->end;
$pagination->max;
$pagination->count;
$pagination->limit;
$pagination->offset;
$pagination->page;
$pagination->maxCols;
$pagination->href;
$pagination->prefix;
$pagination->pagesTotal;
  </code>
</p>

<h3>setCache</h3>
<p>
  Disable or enable row caching mechanism. Row caching keep rows when loaded
  via read/offsetGet or on cursor iteration. Cache is enabled by default, disable
  it with setCache before iterate on big set of data to avoid php memory overflow.
  <code class="lang-php">
$table->setCache(false);
  </code>
</p>

<h3>resetCache</h3>
<p>
  Clean cached rows.
  <code class="lang-php">
$table->resetCache();
  </code>
</p>

<h3>readId</h3>
<p>
  Check if an integer id exists or return an integer id
  from "uniqTextKey" if it exists.
  <code class="lang-php">
$table->readId($id);
  </code>
</p>

<h3>readRow</h3>
<p>
  Return a row as array from id or "uniqTextKey".
  <code class="lang-php">
$table->readRow($id);
  </code>
</p>

<h3>putRow</h3>
<p>
  Create or update a row, depends if primary key or "uniqTextKey" is specified,
  as object property or second parameter,
  and if allready exists in table or not.
  <code class="lang-php">
$table->putRow($obj,$id=null);
  </code>
</p>

<h3>deleteRow</h3>
<p>
  Delete a row from integer primary key or "uniqTextKey".
  <code class="lang-php">
$table->deleteRow($id);
  </code>
</p>

<h3>update</h3>
<p>
  Updating storage of a modified row by it's primary key or "uniqTextKey".
  <code class="lang-php">
$table->update($id);
  </code>
</p>

<h3>getClone</h3>
<p>
  Get a clone of table object, usefull when you want to filter a table and building
  dynamic sql query around an iterator, counter and other featured object that is
  DataTable.
  <code class="lang-php">
$tableFilter = $table->getClone();

//chainable equivalent of
$tableFilter = clone $table;
  </code>
</p>

<h3>loadOne</h3>
<p>
  Load the "_one_" object property from another table to an object.
  <code class="lang-php">
$table->loadOne($obj);

$project = $projects[1];
$users->loadOne($project);
$user = $project->_one_user;
  </code>
  <code class="lang-php">
  </code>
</p>

<h3>loadMany</h3>
<p>
  Load the "_many_" array of objects property from another table to an object.
  <code class="lang-php">
$table->loadMany($obj);

$user = $users[1];
$projects->loadMany($user);
$userProjects = $user->_many_project;
  </code>
</p>

<h3>loadMany2many</h3>
<p>
  Load the "_many2many_" array of objects property from another table to an object.
  A third parameter can be specified for the junction table.
  If you don't specify a junction table, the convention is to order names
  of tables alphabetically and join them with an underscore "_". For instance
  with user and project, the implicit junction table will be "project_user".
  <code class="lang-php">
$table->loadMany2many($obj,$via=null);

$user = $users[1];
$projects->loadMany2many($user);
$userProjects = $user->_many2many_project;

$project = $project[1];
$users->loadMany2many($project);
$projectUsers = $user->_many2many_user;

$user = $users[1];
$projects->loadMany2many($user,'author');
$authorProjects = $user->_many2many_project;

$project = $projects[1];
$users->loadMany2many($project,'author');
$projectAuthors = $user->_many2many_user;
  </code>
</p>


<h3>one</h3>
<p>
  Get the "_one_" object from another table.
  <code class="lang-php">
$table->one($obj);
$user = $users->one($project);
  </code>
</p>

<h3>many</h3>
<p>
  Get the "_many_" array of objects from another table.
  <code class="lang-php">
$table->many($obj);
  </code>
</p>

<h3>many2many</h3>
<p>
  Load the "_many2many_" array of objects from another table.
  A third parameter can be specified for the junction table.
  If you don't specify a junction table, the convention is to order names
  of tables alphabetically and join them with an underscore "_". For instance
  with user and project, the implicit junction table will be "project_user".
  <code class="lang-php">
$table->many2many($obj,$via=null);

$user = $users[1];
$userProjects = $projects->many2many($user);

$project = $project[1];
$projectUsers = $users->many2many($project);

$user = $users[1];
$authorProjects = $projects->many2many($user,'author');

$project = $projects[1];
$projectAuthors = $users->many2many($project,'author');
  </code>
</p>

<h3>on</h3>
<p>
  Attach a callback to a table event. If callback is string, it will be interpreted
  as a method of the entity object.
  If no callback is specified it will take the event name as a method to call
  on entity object.
  You can also use a zIndex like and a prepend option.
  <code class="lang-php">
$table->on($event,$call);

$users->on('afterCreate',function($entity,$db){
echo "User '{$entity->name}' created !";
});
$users->on('afterCreate',function($entity,$db){
echo "First (prepended) callback after user '{$entity->name}' created !";
},0,true);
  </code>
</p>

<h3>off</h3>
<p>
  Detach a callback from a table event. If no callback specified it will remove all
  callbacks attached to the table event.
  You can use the zIndex like as last parameter.
  <code class="lang-php">
$table->off($event,$call);

$userCreated = function($entity,$db){
echo "First Callback after user '{$entity->name}' created !";
};
$users->off('afterCreate',$userCreated,1);
$users->off('afterCreate',$userCreated);
$users->off('afterCreate',null,1);
$users->off('afterCreate');
  </code>
</p>

<h3>trigger</h3>
<p>
  Trigger as indicated by its name, trigger an event on a table and targetting
  a row. The third parameter enable recursivity. The fourth parameter allow you
  to configure recursivity order, if is null it will recurse from called to attached
  row entities, if is true it will recurse from enclosers to nested row entities and
  if is false it will recurse from nested row entities to enclosers.
  <code class="lang-php">
$table->trigger($event, $row, $recursive=false, $flow=null);

$table->trigger('openRecursive', $row, true, true);
$table->trigger('closeRecursive', $row, true, false);

$table->trigger('beforeCreate', $row, true);
$table->trigger('afterCreate', $row, true);

$table->trigger('mySingleRowEvent', $row);
  </code>
</p>

<h3>setCounter</h3>
<p>
  Set a counter callback to use instead of default or implemented one in a DataTable
  specification. The counter callback will be invoked on call to count method
  or function.
  <code class="lang-php">
$table->setCounter($call);

$table = clone $aTable;
//for mysql fulltext
$table->setCounter(function()use($table,$cols,$tableName,$text){
return $table->dataSource->getCell('SELECT COUNT(IF(MATCH ('.$cols.') AGAINST (?), 1, NULL)) FROM '.$tableName,[$text]);
});

$countFulltextSearchResults = count($table);
$countFulltextSearchResults = $table->count();

  </code>
</p>

<h2 id="tablesql">Relational Table</h2>

<h3>exists</h3>
<p>
  Check if a table exists.
  <code class="lang-php">
$table->exists();
  </code>
</p>

<h3>fetch</h3>
<p>
  The fetch method allow you direct access to a cursor from a table,
  so you get each row in a loop and don't overflow your php memory usage while
  traversing a whole table for example.
  <code class="lang-php">
while($row = $table->fetch()){

}
  </code>
</p>

<h3>getRow</h3>
<p>
  Usefull to retrieve one row as an associative array if the configured table query
  is targetting a single row.
  <code class="lang-php">
$row = $table->getRow();
  </code>
</p>

<h3>getAll</h3>
<p>
  Retrieve all row as an array of associative array from the whole table
  or configured table query.
  <code class="lang-php">
$rows = $table->getAll();
  </code>
</p>

<h3>magic iterator</h3>
<p>
  With the magic iterator you can make a loop on the table and traverse the whole
  table or a filtered table, if object was configured.<br>
  A cursor will be used, so, traversing a whole big table
  will not overflow your php memory usage. The key will correspond to
  primaryKey id.
  <code class="lang-php">
foreach($table as $id=>$row){

}

// iterator methods
$table->rewind(); // reset($table);
$table->current(); // current($table);
$table->key(); // key($table);
$table->valid();
$table->next(); // next($table);
  </code>
</p>

<h3>magic count</h3>
<p>
  If you call count function on a table, it will trigger the "count" method.
  It will count all rows of a table
  or the expected results if table object was configured.
  If you used the setCounter method to define a count callback it will use
  the specified callback else it will use countSimple method.
  <code class="lang-php">
$count = count($table);

//count method
$count = $table->count();
  </code>
</p>

<h3>countSimple</h3>
<p>
  The countSimple method use the configured query of the table removing
  it's "order by" clauses and selected columns and select instead a "COUNT(*)"
  on the remaining query.
  <code class="lang-php">
$count = $table->countSimple();
  </code>
</p>

<h3>countNested</h3>
<p>
  The countNested method, like the countSimple, use the configured query
  of the table removing it's "order by" clauses and selected columns and
  select instead just the primary key on the remaining query.
  The difference is that it will execute the query into as a subquery and then
  count the result. So the count process will be slower than in countSimple
  direct query but more relevant in some complex faceted search use cases.
  <code class="lang-php">
$count = $table->countNested();
  </code>
</p>

<h3>countAll</h3>
<p>
  The countAll method will return the total count of rows in a table independently
  from the configured query.
  <code class="lang-php">
$table->countAll();
  </code>
</p>

<h3>createSelect</h3>
<p>
  Get a "SqlComposer\Select" query object configured with the
  table name as main table, and, corresponding to the parent database of table,
  the quote character and table prefix.
  <code class="lang-php">
$select = $table->createSelect();
  </code>
</p>

<h2 id="tablesql-composer">Table Sql Composer API</h2>
<p>
  The following methods are callable on table to configure the "SqlComposer\Select"
  attached to it. You can use them with "SqlComposer\Select" object apart the table
  object to build dynamic SQL queries directly.<br>
  The following methods change the query but nothing is executed before you access
  table via getAll, fetch or loop on iterator.
</p>

<h3>getQuery</h3>
<p>
  Get the query as string.
  <code class="lang-php">
$sql = $table->getQuery();
  </code>
</p>

<h3>getParams</h3>
<p>
  Get the binded parameters.
  <code class="lang-php">
$params = $table->getParams();
  </code>
</p>

<h3>selectMany2many</h3>
<p>
  Add a column select from a table related to current table via a the
  conventional junction table between two tables.
  The primary key of the target table is automatically selected.
  <code class="lang-php">
$table->selectMany2many($select,$colAlias=null);

$articles->selectMany2many('tag.name');
$articles->selectMany2many('tag.name','tag_name');
  </code>
</p>

<h3>selectMany</h3>
<p>
  Add a column select from a table related to current table via foreign key
  of target table.
  The primary key of the target table is automatically selected.
  <code class="lang-php">
$table->selectMany($select,$colAlias=null);

$users->selectMany('project.title');
  </code>
</p>

<h3>selectOne</h3>
<p>
  Add a column select from a table related to current table via foreign key
  of the current table.
  The primary key of the target table is automatically selected.
  <code class="lang-php">
$table->selectOne($select,$colAlias=null);

$projects->selectMany('user.email');
$projects->selectMany('user.name');
  </code>
</p>

<h3>selectRelational</h3>
<p>
  Select relations via multidimensional queries. Here is a convention:
</p>
<ul>
  <li>&lt; one ( parent row )</li>
  <li>&gt; many ( own rows )</li>
  <li>&lt;&gt; many2many ( many to many / shared rows )</li>
</ul>
<p>
  You can access data through an infinity of tables via their junctions.
  Whites spaces have no signification, they will be removed but you can use
  them to aerate the code.<br>
  The relational select will build multidimensional sub arrays by exploding
  the result of sql aggregate functions (specific to each database).
  <code class="lang-php">
$table->selectRelational($select,$colAlias=null);

$project->selectRelational(' < user.email ');
//equivalent of $projects->selectOne('user.email');

$users->selectRelational(' > project.title');
//equivalent of $users->selectMany('project.title');

$articles->selectRelational(' <> tag.name ');
//equivalent of $articles->selectMany2many('tag.name');

//get tag names used in others articles from the user related to each article
$articles->selectRelational(' <user >articles <>tag .name ');
  </code>
</p>

<h3>hasSelectRelational</h3>
<p>
  Check if the configured query has at least one relational select using aggregation
  and configured before with one of the following methods:
  selectRelational, selectOne, selectMany, selectMany2many.
  <code class="lang-php">
if($table->hasSelectRelational()){

}
  </code>
</p>

<h3>tableJoin</h3>
<p>
  Add a simple join on a table adding join table in first parameter, on junction
  in second parameter and binding parameters optionaly in third parameter.
  <code class="lang-php">
$table->tableJoin($table, $join, array $params = null);

$projects->tableJoin('JOIN user', 'ON user.id = project.user_id');
  </code>
</p>

<h3>joinAdd</h3>
<p>
  Add a join parameter.
  <code class="lang-php">
$table->joinAdd($join,array $params = null);

$projects->joinAdd('JOIN user ON user.id = project.user_id');
  </code>
</p>

<h3>join</h3>
<p>
  Add a join parameter with implicit regular JOIN.
  <code class="lang-php">
$table->join($join, array $params = null);

$projects->join('user ON user.id = project.user_id');
  </code>
</p>

<h3>joinLeft</h3>
<p>
  Add a join left parameter.
  <code class="lang-php">
$table->joinLeft($join, array $params = null);

$projects->joinLeft('user ON user.id = project.user_id');
  </code>
</p>

<h3>joinRight</h3>
<p>
  Add a join right parameter.
  <code class="lang-php">
$table->joinRight($join, array $params = null);

$projects->joinRight('user ON user.id = project.user_id');
  </code>
</p>

<h3>joinOn</h3>
<p>
  Add a "join on" snippet which will be related to ordered previous join.
  <code class="lang-php">
$table->joinOn($join, array $params = null);

$projects->joinLeft('user ON user.id');
$projects->joinOn('user.id = project.user_id');
  </code>
</p>

<h3>from</h3>
<p>
  Add a table or a sub-query to "FROM" clause.
  <code class="lang-php">
$table->from($table, array $params = null);
  </code>
</p>

<h3>unTableJoin</h3>
<p>
  <code class="lang-php">
$table->unTableJoin($table=null,$join=null,$params=null);
  </code>
</p>

<h3>unJoin</h3>
<p>
  <code class="lang-php">
$table->unJoin($join=null,$params=null);
  </code>
</p>

<h3>unFrom</h3>
<p>
  <code class="lang-php">
$table->unFrom($table=null,$params=null);
  </code>
</p>

<h3>setParam</h3>
<p>
  <code class="lang-php">
$table->setParam($k,$v);
  </code>
</p>

<h3>getParam</h3>
<p>
  <code class="lang-php">
$table->getParam($k);
  </code>
</p>

<h3>unWhere</h3>
<p>
  <code class="lang-php">
$table->unWhere($where=null,$params=null);
  </code>
</p>

<h3>unWith</h3>
<p>
  <code class="lang-php">
$table->unWith($with=null,$params=null);
  </code>
</p>

<h3>unWhereIn</h3>
<p>
  <code class="lang-php">
$table->unWhereIn($where,$params=null);
  </code>
</p>

<h3>unWhereOp</h3>
<p>
  <code class="lang-php">
$table->unWhereOp($column, $op,  array $params=null);
  </code>
</p>

<h3>unOpenWhereAnd</h3>
<p>
  <code class="lang-php">
$table->unOpenWhereAnd();
  </code>
</p>

<h3>unOpenWhereOr</h3>
<p>
  <code class="lang-php">
$table->unOpenWhereOr();
  </code>
</p>

<h3>unOpenWhereNotAnd</h3>
<p>
  <code class="lang-php">
$table->unOpenWhereNotAnd();
  </code>
</p>

<h3>unOpenWhereNotOr</h3>
<p>
  <code class="lang-php">
$table->unOpenWhereNotOr();
  </code>
</p>

<h3>unCloseWhere</h3>
<p>
  <code class="lang-php">
$table->unCloseWhere();
  </code>
</p>

<h3>where</h3>
<p>
  <code class="lang-php">
$table->where($where, array $params = null);
  </code>
</p>

<h3>whereIn</h3>
<p>
  <code class="lang-php">
$table->whereIn($where, array $params);
  </code>
</p>

<h3>whereOp</h3>
<p>
  <code class="lang-php">
$table->whereOp($column, $op, array $params=null);
  </code>
</p>

<h3>openWhereAnd</h3>
<p>
  <code class="lang-php">
$table->openWhereAnd();
  </code>
</p>

<h3>openWhereOr</h3>
<p>
  <code class="lang-php">
$table->openWhereOr();
  </code>
</p>

<h3>openWhereNotAnd</h3>
<p>
  <code class="lang-php">
$table->openWhereNotAnd();
  </code>
</p>

<h3>openWhereNotOr</h3>
<p>
  <code class="lang-php">
$table->openWhereNotOr();
  </code>
</p>

<h3>closeWhere</h3>
<p>
  <code class="lang-php">
$table->closeWhere();
  </code>
</p>

<h3>with</h3>
<p>
  <code class="lang-php">
$table->with($with, array $params = null);
  </code>
</p>

<h3>select</h3>
<p>
  <code class="lang-php">
$table->select($select, array $params = null);
  </code>
</p>

<h3>distinct</h3>
<p>
  <code class="lang-php">
$table->distinct($distinct = true);
  </code>
</p>

<h3>groupBy</h3>
<p>
  <code class="lang-php">
$table->groupBy($group_by, array $params = null);
  </code>
</p>

<h3>withRollup</h3>
<p>
  <code class="lang-php">
$table->withRollup($with_rollup = true);
  </code>
</p>

<h3>orderBy</h3>
<p>
  <code class="lang-php">
$table->orderBy($order_by, array $params = null);
  </code>
</p>

<h3>sort</h3>
<p>
  <code class="lang-php">
$table->sort($desc=false);
  </code>
</p>

<h3>limit</h3>
<p>
  <code class="lang-php">
$table->limit($limit);
  </code>
</p>

<h3>offset</h3>
<p>
  <code class="lang-php">
$table->offset($offset);
  </code>
</p>

<h3>having</h3>
<p>
  <code class="lang-php">
$table->having($having, array $params = null);
  </code>
</p>

<h3>havingIn</h3>
<p>
  <code class="lang-php">
$table->havingIn($having, array $params);
  </code>
</p>

<h3>havingOp</h3>
<p>
  <code class="lang-php">
$table->havingOp($column, $op, array $params=null);
  </code>
</p>

<h3>openHavingAnd</h3>
<p>
  <code class="lang-php">
$table->openHavingAnd();
  </code>
</p>

<h3>openHavingOr</h3>
<p>
  <code class="lang-php">
$table->openHavingOr();
  </code>
</p>

<h3>openHavingNotAnd</h3>
<p>
  <code class="lang-php">
$table->openHavingNotAnd();
  </code>
</p>

<h3>openHavingNotOr</h3>
<p>
  <code class="lang-php">
$table->openHavingNotOr();
  </code>
</p>

<h3>closeHaving</h3>
<p>
  <code class="lang-php">
$table->closeHaving();
  </code>
</p>

<h3>unSelect</h3>
<p>
  <code class="lang-php">
$table->unSelect($select=null, array $params = null);
  </code>
</p>

<h3>unDistinct</h3>
<p>
  <code class="lang-php">
$table->unDistinct();
  </code>
</p>

<h3>unGroupBy</h3>
<p>
  <code class="lang-php">
$table->unGroupBy($group_by=null, array $params = null);
  </code>
</p>

<h3>unWithRollup</h3>
<p>
  <code class="lang-php">
$table->unWithRollup();
  </code>
</p>

<h3>unOrderBy</h3>
<p>
  <code class="lang-php">
$table->unOrderBy($order_by=null, array $params = null);
  </code>
</p>

<h3>unSort</h3>
<p>
  <code class="lang-php">
$table->unSort();
  </code>
</p>

<h3>unLimit</h3>
<p>
  <code class="lang-php">
$table->unLimit();
  </code>
</p>

<h3>unOffset</h3>
<p>
  <code class="lang-php">
$table->unOffset();
  </code>
</p>

<h3>unHaving</h3>
<p>
  <code class="lang-php">
$table->unHaving($having=null, array $params = null);
  </code>
</p>

<h3>unHavingIn</h3>
<p>
  <code class="lang-php">
$table->unHavingIn($having, array $params);
  </code>
</p>

<h3>unHavingOp</h3>
<p>
  <code class="lang-php">
$table->unHavingOp($column, $op, array $params=null);
  </code>
</p>

<h3>unOpenHavingAnd</h3>
<p>
  <code class="lang-php">
$table->unOpenHavingAnd();
  </code>
</p>

<h3>unOpenHavingOr</h3>
<p>
  <code class="lang-php">
$table->unOpenHavingOr();
  </code>
</p>

<h3>unOpenHavingNotAnd</h3>
<p>
  <code class="lang-php">
$table->unOpenHavingNotAnd();
  </code>
</p>

<h3>unOpenHavingNotOr</h3>
<p>
  <code class="lang-php">
$table->unOpenHavingNotOr();
  </code>
</p>

<h3>unCloseHaving</h3>
<p>
  <code class="lang-php">
$table->unCloseHaving();
  </code>
</p>

<h3>hasColumn</h3>
<p>
  <code class="lang-php">
$table->hasColumn();
  </code>
</p>

<h3>getColumn</h3>
<p>
  <code class="lang-php">
$table->getColumn();
  </code>
</p>

<h3>hasTable</h3>
<p>
  <code class="lang-php">
$table->hasTable();
  </code>
</p>

<h3>getTable</h3>
<p>
  <code class="lang-php">
$table->getTable();
  </code>
</p>

<h3>hasJoin</h3>
<p>
  <code class="lang-php">
$table->hasJoin();
  </code>
</p>

<h3>getJoin</h3>
<p>
  <code class="lang-php">
$table->getJoin();
  </code>
</p>

<h3>hasFrom</h3>
<p>
  <code class="lang-php">
$table->hasFrom();
  </code>
</p>

<h3>getFrom</h3>
<p>
  <code class="lang-php">
$table->getFrom();
  </code>
</p>

<h3>hasWhere</h3>
<p>
  <code class="lang-php">
$table->hasWhere();
  </code>
</p>

<h3>hasWith</h3>
<p>
  <code class="lang-php">
$table->hasWith();
  </code>
</p>

<h3>getWhere</h3>
<p>
  <code class="lang-php">
$table->getWhere();
  </code>
</p>

<h3>getWith</h3>
<p>
  <code class="lang-php">
$table->getWith();
  </code>
</p>

<h3>hasSelect</h3>
<p>
  <code class="lang-php">
$table->hasSelect();
  </code>
</p>

<h3>getSelect</h3>
<p>
  <code class="lang-php">
$table->getSelect();
  </code>
</p>

<h3>hasDistinct</h3>
<p>
  <code class="lang-php">
$table->hasDistinct();
  </code>
</p>

<h3>hasGroupBy</h3>
<p>
  <code class="lang-php">
$table->hasGroupBy();
  </code>
</p>

<h3>getGroupBy</h3>
<p>
  <code class="lang-php">
$table->getGroupBy();
  </code>
</p>

<h3>hasWithRollup</h3>
<p>
  <code class="lang-php">
$table->hasWithRollup();
  </code>
</p>

<h3>hasHaving</h3>
<p>
  <code class="lang-php">
$table->hasHaving();
  </code>
</p>

<h3>getHaving</h3>
<p>
  <code class="lang-php">
$table->getHaving();
  </code>
</p>

<h3>hasOrderBy</h3>
<p>
  <code class="lang-php">
$table->hasOrderBy();
  </code>
</p>

<h3>getOrderBy</h3>
<p>
  <code class="lang-php">
$table->getOrderBy();
  </code>
</p>

<h3>hasSort</h3>
<p>
  <code class="lang-php">
$table->hasSort();
  </code>
</p>

<h3>getSort</h3>
<p>
  <code class="lang-php">
$table->getSort();
  </code>
</p>

<h3>hasLimit</h3>
<p>
  <code class="lang-php">
$table->hasLimit();
  </code>
</p>

<h3>getLimit</h3>
<p>
  <code class="lang-php">
$table->getLimit();
  </code>
</p>

<h3>hasOffset</h3>
<p>
  <code class="lang-php">
$table->hasOffset();
  </code>
</p>

<h3>getOffset</h3>
<p>
  <code class="lang-php">
$table->getOffset();
  </code>
</p>


<h2 id="entity">Entity Model</h2>
<p>
  The object representing a row of table is called entity. The set of the classes
  to instanciate for make theses objects is called entity model.
  EntityModel is a basic class that you can extends to build
  evenemential entities. You can also implements the FoxORM Observer interface
  if you don't want to extends EntityModel.<br>
  The corresponding class to a table will be used when
  factory, create, read, update or delete a row object.
  <br>
  Folowing is not evenemential because is not an instance of Observer,
  even if you add the events methods they will not be triggered:
  <code class="lang-php">
namespace EntityModel;
class User{
}
  </code>

  You have to add all the events methods.
  <code class="lang-php">
namespace EntityModel;
class User implements FoxORM\Observer{
function beforeRecursive(){}
function beforePut(){}
function beforeCreate(){}
function beforeRead(){}
function beforeUpdate(){}
function beforeDelete(){}
function afterPut(){}
function afterCreate(){}
function afterRead(){}
function afterUpdate(){}
function afterDelete(){}
function afterRecursive(){}
}
  </code>

  The events methods are allready implemented but
  you can overload the ones which interest you.
  <code class="lang-php">
namespace EntityModel;
class User extends \FoxORM\EntityModel{
function afterCreate(){}
function afterRead(){}
function afterUpdate(){}
function afterDelete(){}
}
  </code>
</p>

<h2 id="observer">Observer Workflow</h2>
<p>
  The observer workflow is a complete evenemential system on which you can rely to
  control your entities model.
  The set of events are:
</p>
<ul>
  <li><a href="api-documentation#before-recursive">beforeRecursive</a></li>
  <li><a href="api-documentation#before-put">beforePut</a></li>
  <li><a href="api-documentation#before-create">beforeCreate</a></li>
  <li><a href="api-documentation#before-read">beforeRead</a></li>
  <li><a href="api-documentation#before-update">beforeUpdate</a></li>
  <li><a href="api-documentation#before-delete">beforeDelete</a></li>
  <li><a href="api-documentation#after-put">afterPut</a></li>
  <li><a href="api-documentation#after-create">afterCreate</a></li>
  <li><a href="api-documentation#after-read">afterRead</a></li>
  <li><a href="api-documentation#after-update">afterUpdate</a></li>
  <li><a href="api-documentation#after-delete">afterDelete</a></li>
  <li><a href="api-documentation#after-recursive">afterRecursive</a></li>
</ul>
<p>
  See <a href="api-documentation#entity">Entity Model</a> for methods
  implementation.
</p>
<h3 id="before-recursive">beforeRecursive</h3>
<p>
  This event is triggered recursively from the top encloser entity to the nested ones
  when a put (create or update) is performed and before all other events.
  You can use it to validate the set of all the entities you are about to store.
</p>

<h3 id="before-put">beforePut</h3>
<p>
  This event is triggered recursively in the order the entities will be stored
  when a put (insert or update) is performed. This event is trigerred
  after beforeRecursive and before beforeCreate or beforeUpdate event.
</p>

<h3 id="before-create">beforeCreate</h3>
<p>
  This event is triggered recursively in the order the entities will be stored
  when a create (insert) is performed. This event is trigerred
  after beforePut event and before the storage execution.
</p>

<h3 id="before-read">beforeRead</h3>
<p>
  This event is triggered after an entitie object is factorised and before
  performing the read query to the database.
</p>

<h3 id="before-update">beforeUpdate</h3>
<p>
  This event is triggered recursively in the order the entities will be stored
  when an update is performed. This event is trigerred
  after beforePut event and before the storage execution.
</p>

<h3 id="before-delete">beforeDelete</h3>
<p>
  This event is triggered when an delete is performed. This event is trigerred
  before the storage execution.
</p>

<h3 id="after-put">afterPut</h3>
<p>
  This event is triggered recursively in the order the entities was stored
  when a put (insert or update) is performed. This event is trigerred
  after the storage execution and after afterCreate or afterUpdate event.
</p>

<h3 id="after-create">afterCreate</h3>
<p>
  This event is triggered recursively in the order the entities was stored
  when a create (insert) is performed. This event is trigerred
  after the storage execution and before afterRecursive event.
</p>

<h3 id="after-read">afterRead</h3>
<p>
  This event is triggered after an entity object has been loaded with the data from
  performed database read query.
</p>

<h3 id="after-update">afterUpdate</h3>
<p>
  This event is triggered recursively in the order the entities was stored
  when an update is performed. This event is trigerred
  after the storage execution and before afterRecursive event.
</p>

<h3 id="after-delete">afterDelete</h3>
<p>
  This event is triggered when an delete is performed. This event is trigerred
  after the storage execution.
</p>

<h3 id="after-recursive">afterRecursive</h3>
<p>
  This event is triggered recursively from the nested entities to the top encloser one
  when a put (create or update) is performed and after all other events.
</p>

<h2 id="relations">Relations</h2>
<p>
  You can access or make relations in many ways, here is somes examples:<br>
  Using facade way to read it directly:
  <code class="lang-php">
foreach(F::many2one($project,'user') as $user){
debug($user);
}

F::loadMany2one($project,'user');
debug($project);

foreach(F::one2many($user,'project') as $project){
debug($project);
}
  </code>
  Storing with explicit "_many_" meta prefix which do a one to many relation.
  The _x_ suffix specify that is an exclusive link.
  When it's an exclusive relation the list are considered to be dependent
  on their parent row. If it's removed, they will be deleted as well.
  <code class="lang-php">
$user = F::create('user',[
'name'=>'test',
'_many_note_x_'=>[
[
  'description'=>'Testing relational CRUD'
],
],
]);
  </code>
  Storing implicit relations: if there is no prefix to key of not
  scalar value, there are implicits rules.
  An array of objects mean many, and an object mean one.
  <code class="lang-php">
F::create('user',[
'name'=>'test',
'project_x_'=>[
(object)[
  'name'=>'myproject'
],
(object)[
  'name'=>'myproject2'
],
],
]);

F::create('project',[
'name'=>'myproject',
'user_x_'=>(object)[
'name'=>'test'
],
]);
  </code>
  You can even build directly some many to many rows related by an implicit
  conventional junction table.
  <code class="lang-php">
$user = F::create('user',[
'name'=>'test',
'_many2many_project_x_'=>[
[
  'name'=>'myproject'
],
[
  'name'=>'myproject2'
],
],
]);
  </code>
  Load the related rows before updating one if you don't want to remove
  all of them when storing.
  <code class="lang-php">
$user = F::read('user',1);
$user->_many2many_project_x_ = F::many2many($user,'project')->getAll();
$user->_many2many_project_x_[21]['description'] = 'updated '.time();
$user = F::update($user);
  </code>
  Use alias relations with key different from "_type" meta property.
  <code class="lang-php">
$user = F::create('user',[
'name'=>'test',
'_many_note_x_'=>[
[
  '_type'=>'info',
  'description'=>'Making CRUD alias'
],
],
]);

$user = F::create('info',[
'name'=>'Making CRUD alias',
'_one_author_x_'=>[
'_type'=>'user',
'name'=>'test',
],
]);
  </code>
</p>


<h2 id="source">Data Source Plugin</h2>
<p>
  To create a DataSource plugin for support an other database you have to
  create tow class with a name uppercased on first character which
  correspond to the name of database type. One of theses two class
  have to extends DataSource or DataSource\SQL if it's an SQL database
  and placed in DataSource sub namespace. The second have to extends DataTable
  or DataTable\SQL if it's SQL database and placed in DataTable sub namespace.
  Let's take an example, for database type called mybase:<br>
  in DataSource/Mybase.php
  <code class="lang-php">
namespace RedCat\FoxORM\DataSource;
class Mybase extends \FoxORM\DataSource{

}
  </code>
  in DataTable/Mybase.php
  <code class="lang-php">
namespace RedCat\FoxORM\DataTable;
class Mybase extends \FoxORM\DataTable{

}
  </code>
  and use it:
  <code class="lang-php">
$bases[0] = [
'type'=>'mybase',
'host'=>'localhost',
'port'=>'3306',
'name'=>'my_db_name',
];
  </code>
  Implements the abstract required methods and see how other classes works
  by taking a look on their respectives codes to understand how to design your
  database layers.
</p>
        </div>
      </article>
    </div>
  </main>
	<footer>
		<incorpore "redcat-powered.btml">
		<div class="foot">

			<div>
				 FoxORM · Created by <a href="https://github.com/surikat" target="_blank">Jo/Surikat</a>
			</div>

			<div>
				 <img src="img/foxorm-24.png"> The ORM of <a href="https://github.com/redcatphp" target="_blank">RedCatPHP</a>
			</div>

			<div class="license">
				Code licensed under
				<a href="https://opensource.org/licenses/mit-license.html" target="_blank">MIT License</a>
			</div>

		</div>
	</footer>
	<script type="text/javascript" src="js/js.js"></script>
	<script type="text/javascript" src="js/js.alias-asset.js"></script>
	<script type="text/javascript">
		$js('js/script');
		$js('js/page-scroll');
	</script>
  <script type="text/javascript" src="plugins/highlightjs/highlight-loader.js"></script>
</body>
</html>